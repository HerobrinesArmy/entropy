;by lukew4lker
:drive_discovery
hwn z
set j, 0x0
set a, z
jsr mm_request
jsr fatal_error
set [varintrgr], a
set i, a
 
:.drive_loop0
hwq j
ife a, 0x24c5  
        ife b, 0x4fd5
                jsr .add_drive
ife j, z
        set pc, .exit0
ife [drive_count], 0xf ; exit if the number of drives found is 16
        set pc, .exit0
add j, 1
set pc, .drive_loop0
 
:varintrgr
.dat 0x0
 
:.add_drive
set [i], j
add i, 1
add [drive_count], 1
set pc, pop
 
:.exit0
set a, [drive_count]
set j, [varintrgr]
set i, 0x0
set x, a
mul a, 8
set b, drive_count
mul b, 0x50
add a, b
jsr mm_request
jsr fatal_error
set y, a
set [io_drive_data], y
add b, a
set z, b
 
:.loop1
ifg i, x
        set pc, .exitloop1
set [y], j; hardware address
add j, 1
add i, 1
set [y+1], z; queue location
add z, 0x50
add y, 7
set pc, .loop1
 
:.exitloop1
set i, drive_count
 
 
:.loop2
ifg z, i
         set pc, .exitloop2
set a, 0
set [y+3], 0x0;used to make sure that we have a blank slate when doing bors
hwi [y]
ife b, 0xffff
        set pc, .halt
:.ref
set pc, [a+.ref]
.dat .nomedia
.dat .ready
.dat .wp
.dat .halt
 
:.nomedia
and [y+3], 0xfffd
set pc, .refend
 
:.ready
bor [y+3], 0x2
set pc, .refend
 
:.wp
bor [y+3], 0x6
set pc, .refend
 
:.halt
sub pc, 1
 
:.refend
add y, 7
add z, 1
set pc, .loop2
 
:.exitloop2
set a, .varintrgr
jsr mm_clear
jsr fatal_error
sub pc, 1