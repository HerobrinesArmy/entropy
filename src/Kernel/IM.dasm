;INTERRUPT MANAGER by Lucus

;Implements dynamic interrupt handling for kernel and processes.

;IM table entry:
;0x0 handler or 0 if no handler
;0x1 extra message word

;Handlers get called with the hardware address of the calling hardware in A
;and the message word in B, they can destroy A, B and EX but must preserve all other registers

.define im_hardware_flag		0x1000	;Never set this to 0

:im_interrupt_handler
set push, ex
set push, b
sub a, im_hardware_flag
hwn b
sub b, 1
ifg a, b
set pc, .no_handler         ;interrupt does not belong to hardware, unknown source
set b, a
shl b, 1
add b, [im_table_address]
ife [b], 0
set pc, .no_handler
set push, [b]
set b, [b + 1]
jsr pop
:.no_handler	;fail silently
set b, pop
set ex, pop
rfi 0

;A is hardware address
;B is handler location
;C is message word
;Return: A is 0 on success, errno on failure
:im_request
add [pm_semaphore], 1
shl a, 1
add a, [im_table_address]
ifn [a], 0
set pc, .already_in_use
set [a], b
set [a + 1], c
set a, 0		;success
set pc, pm_unlock ;Short for: JSR label; SET PC, POP
:.already_in_use
set a, err_already_in_use
set pc, pm_unlock ;Short for: JSR label; SET PC, POP

:im_free
add [pm_semaphore], 1
shl a, 1
add a, [im_table_address]
set [a], 0
set pc, pm_unlock ;Short for: JSR label; SET PC, POP

;DATA
:im_table_address	.dat 0x0000

