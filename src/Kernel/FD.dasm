;FILE DRIVER by Lucus
;Not implemented yet

;DATA
:fd_current_drive   .dat 0x0000


:fd;EXTERNAL INTERFACE
;ABCX Input
;A is the requested operation
;B,C and X are define by their apropriate subfunction. 
set push, y
set push, z
set push, i
set push, j
set push, ex

add a, 1; incriment so we can use 0 as an input
:.aref
set pc, [a+pc]
.dat fd_get_drive_data
.dat fd_update_fat
.dat fd_load_fat





:fd_end
sub a, 1 ;restore a
set pop, ex
set pop, j
set pop, i
set pop, z
set pop, y
set pc, pop



:fd_get_drive_data
;x is the drive number.
;b is the where we store the pointer.
set y, x
mul y, 6
add y, [io_drive_data]
set [b], y
set pc, fd_end 

:fd_update_fat
;x is the drive number
;returns y 0xffff if unable
set push, b
set push, a
jsr fd_allocate ;setup z parameter. Notice I don't push any of the the registers I'm not using because they have already been pushed by the external interface.
set y, x
mul y, 6
add y, [io_drive_data]
set a, y
set b, 0x3
set c, 0x7; sector of first third of FAT on disk
jsr fd_add_job
ife a, 0xffff; check 
set pc, .err0
set [z+0x7], i
add a, 0x200;move pointer so we can do next write.
set c, 0x8
jsr fd_add_job
ife a, 0xffff
set pc, .err0
set [z+0x8], i
add a, 0x200
set c, 0x9
jsr fd_add_job
ife a, 0xffff
set pc, .err0
set [z+0x9], i
;NOT Finished 

:fd_allocate
set a, 0x10
jsr mm_request
ife a, 0xffff
set pc, fatal_error
set z, a
set pc, pop

:fd_load_fat
;Written By LukeW4lker
;x is the drive to load the FAT from.
;a, b and i are destroyed.
set a, 0x600
jsr mm_request
ife a, 0xffff
set pc, fatal_error
set b, 0x2
set c, 0x7
jsr fd_add_job
set [z+0x7], i
add a, 0x200
set c, 0x8
jsr fd_add_job
set [z+0x8], i
add a, 0x200
set c, 0x9
jsr fd_add_job
set [z+0x9], i
;NOT finished 

:fd_add_job
;By LukeW4lker
; a is the memory location to use.
; b is the operation to perform. (bool; 2 = read 3 = write)
; c is the sector to work on.
; x is the drive we are going to be using. 
; Uses the allocated memory from the external interface and destroys y, ex and i 
; i becomes the location of the IO object add_job creates
ifg x, [io_drive_count]
	set pc, .err0
set [z+0xf], x
mul x, 0x6 ; length of drive data entry
add x, [io_drive_data]
set i, [x+2]
and i, 0x4
ifn i, 0x0 
	ifg b, 0x2
		set pc, .err1
set i, [x+3]; set i to drive data flag word
and i, 0x8 
ifn i, 0x0 ; check drive functionality
	set pc, .errfatal 
:.infloop ; loop until the queue is unlocked
IAQ 0x1
set i, [x+2]
and i, 0x20
ife i, 0
	set pc, .exitinfloop
IAQ 0x0
jsr pm_block_me
set pc, .infloop
:.exitinfloop
bor [x+2], 0x20; lock the queue 
IAQ 0x0
set y, [x+1]

;y is the start the queue we will add an entry to.
jsr .find_freespace
;y is now the location of the free entry.
set i, a
jsr io_object_create
set [y],   i ; memory working location
set [y+1], b ; sector
set [y+2], c ; operation
set [y+3], a ; location of mutex object
set [y+4], 0x0 ; set entry to alive
sub [x+2], 0x20; removes lock
ifn [x+4], 0x0 ; checks if queue is empty.
set pc, pop
set x, [z+0xf]
add x, 0x1000
jsr .startoperator
xor a, i
xor i, a
xor a, i
set pc, pop

:.findspaceErr
set y, [z+0xe]
jsr pm_block_me
set pc, .loopenter
;Loops here forever until it finds a free entry

:.find_freespace
set [z+0xe], y
set i, 0x50
add i, y
;i is the end of the queue
:.loopenter
sub y, 5
:.loop0
add y, 5
ifg y, i
	set pc, .findspaceErr
ifn [y+4], 0x5 ;check if the entry is mortem
	set pc, .loop0
set pc, pop

:.errfatal
set a, 0xffff
set x, 0xffff
set pc, pop

:.err0
set a, 0xffff
set x, err_oob
set pc, pop

:.err1
set a, 0xffff
set b, err_wp
set pc, pop

:.startoperator
int [x]
set pc, pop
