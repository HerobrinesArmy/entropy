;FILE DRIVER by Lucus
;Not implemented yet

;DATA
:fd_current_drive   .dat 0x0000

:fd_load_fat
;Written By LukeW4lker
;x is the drive to load the FAT from.
;a, b and i are destroyed.
set a, 0x600
jsr mm_request
ife a, 0xffff
set pc, fatal_error
set b, 0x2
set c, 0x7
jsr fd_add_job
set [z+0x7], i
add a, 0x200
set c, 0x8
jsr fd_add_job
set [z+0x8], i
add a, 0x200
set c, 0x9
jsr fd_add_job
set [z+0x9], i
;Kill me, Please. XI
;Later.
:.loop0
set b,  [z+0x7]
ifn b, 0x0
set pc, .chk0
jsr pm_block_me
set pc, .loop0
:.chk0
xor b, 0b0000000110000000
ifg b, 0x0
set pc, fatal_error
:.loop1
set b,  [z+0x8]
ifn b, 0x0
set pc, .chk1
jsr pm_block_me
set pc, .loop1
:.chk1
xor b, 0b0000000110000000
ifg b, 0x0
set pc, fatal_error
:.loop2
set b,  [z+0x9]
ifn b, 0x0
set pc, .chk2
jsr pm_block_me
set pc, .loop2
:.chk2
xor b, 0b0000000110000000
ifg b, 0x0
set pc, fatal_error
;set_fat_location_data
sub a, 0x400
mul x, 0x6
set b, io_drive_data
add b, x
set [b+5], a
set pc, pop










:fd_add_job
;By LukeW4lker
; a is the memory location to use.
; b is the operation to perform. (bool; 2 = read 3 = write)
; c is the sector to work on.
; x is the drive we are going to be using. 
; Uses the allocated memory from the external interface and destroys y, ex and i 
; i becomes the location of the IO object add_job creates
ifg x, [io_drive_count]
	set pc, .err0
set [z+0xf], x
mul x, 0x6 ; length of drive data entry
add x, [io_drive_data]
set i, [x+2]
and i, 0x4
ifn i, 0x0 
	ifg b, 0x2
		set pc, .err1
set i, [x+3]; set i to drive data flag word
and i, 0x8 
ifn i, 0x0 ; check drive functionality
	set pc, .errfatal 
:.infloop ; loop until the queue is unlocked
IAQ 0x1
set i, [x+2]
and i, 0x20
ife i, 0
	set pc, .exitinfloop
IAQ 0x0
jsr pm_block_me
set pc, .infloop
:.exitinfloop
bor [x+2], 0x20; lock the queue 
IAQ 0x0
set y, [x+1]

;y is the start the queue we will add an entry to.
jsr .find_freespace
;y is now the location of the free entry.
set i, a
jsr io_object_create
set [y],   i ; memory working location
set [y+1], b ; sector
set [y+2], c ; operation
set [y+3], a ; location of mutex object
set [y+4], 0x0 ; set entry to alive
sub [x+2], 0x20; removes lock
ifn [x+4], 0x0 ; checks if queue is empty.
set pc, pop
set x, [z+0xf]
add x, 0x1000
jsr .startoperator
xor a, i
xor i, a
xor a, i
set pc, pop

:.findspaceErr
set y, [z+0xe]
jsr pm_block_me
set pc, .loopenter
;Loops here forever until it finds a free entry

:.find_freespace
set [z+0xe], y
set i, 0x50
add i, y
;i is the end of the queue
:.loopenter
sub y, 5
:.loop0
add y, 5
ifg y, i
	set pc, .findspaceErr
ifn [y+4], 0x5555 ;check if the entry is mortem
	set pc, .loop0
set pc, pop

:.errfatal
set a, 0xffff
set x, 0xffff
set pc, pop

:.err0
set a, 0xffff
set x, err_oob
set pc, pop

:.err1
set a, 0xffff
set b, err_wp
set pc, pop

:.startoperator
int [x]
;ex is what the drive returned when it was polled by the scheduler.

set pc, pop





