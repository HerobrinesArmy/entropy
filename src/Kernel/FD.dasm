;FILE DRIVER by Lucus

;Not implemented yet

;DATA
:fd_current_drive   .dat 0x0000

:fd_drives
.dat 0x0
:io_drive_data
.dat 0x0

:fd_add_job
;By LukeW4lker
;a is the memory location to use.
;b is the operation to perform. (bool; 2 = read 3 = write)
;c is the sector to work on.
;x is the drive we are going to be using. 
;Uses the allocated memory from the external interface and destroys y and i 
;y becomes the location of the entry in the queue and [y+2] is the entry's current state. (used to return errors)
ifg x, [drive_count]
	set pc, .err0
set [z+0xf], x
mul x, 0x5
add x, [io_drive_data]
set i, [x+3]
and i, 0x5
ifn i, 0x0 
	ifg b, 0x2
		set pc, .err1
set i, [x+3]
and i, 0x8
ifn i, 0x0 
set pc, .errfatal
add x, 5

:.infloop ; loop until the queue is unlocked
IAQ 0x1
set i, [x+3]
and i, 0x1
ife i, 0
	set pc, .exitinfloop
IAQ 0x0
set i, [x+3]
set pc, .infloop
:.exitinfloop
add [x+3], 1
IAQ 0x0
set y, [x+1]
set i, 0x80
add i, y 
;i is the end of the queue
;y is the start the queue we will add an entry to.
jsr .find_freespace
;y is now the location of the free entry.
set [y], a
set [y+1], b
set [y+2], c
set [y+3], [sp]
sub [x+3], 1
ife [x+2], 0x0
jsr .startoperator
set x, [z+0xe]
set pc, pop

:.findspaceErr
set y, [z+0xe]
jsr pm_block
set pc, .loopenter

:.find_freespace
set [z+0xe], y

:.loopenter
sub y, 5

:.loop0
add y, 5
ifg y, i
	set pc, .findspaceErr
ifn [y], 0xffff
	set pc, .loop0
set pc, pop

:.findspaceErr
set y, [z+0xe]
jsr pm_block
set pc, .loopenter

:.nextentry
add y, 5
set pc, .loop0

:.errfatal
set a, 0xffff
set x, 0xffff
set pc, pop

:.err0
set a, 0xffff
set x, err_oob
set pc, pop
:.err1
set a, 0xffff
set b, err_wp
set pc, pop

:io_ack
;y is the location of the entry in the queue to acknowldge and mark it as free
set [y], 0xffff
set pc, pop

:.startoperator
int [x]
;ex is what the drive returned when it was polled by the scheduler.
set pc, pop