;DRIVE MANAGER by Lucus

;Handles IO operations for all m35fd drives

dm_handler
;A=hardware address, B=drive entry
set push, c
set push, x
set push, y
set push, z
set push, i

;POLL DRIVE
set z, b
set a, 0
hwi [z]

;IF STATE_BUSY: RETURN
ife b, 3
set pc, .ret

;IF ERROR: FAIL current ELSE SUCCESS current
set i, [z+1]
ife i, 0
set pc, .ret    ;A state change occured while there was no operation running
set [i], c      ;set return state to error code
ifn c, 0        ;if there was an error
bor [i], 0x10   ;add 0x10 error flag
set a, [i+3]
jsr pm_unblock
set i, [i+4]    ;proceed to next operation

;IF QUEUE is empty: RETURN
ife i, 0
set pc, .ret

;IF ERROR_FATAL OR STATE_NO_MEDIA: FAIL QUEUE
ifn c, -1
ifn b, 0
set pc, .mainloop
:.failloop
set [i], 0x20
set a, [i+3]
jsr pm_unblock
set i, [i+4]
ifn i, 0
set pc, .failloop
set pc, .ret

:.mainloop
;Start next operation
set x, [i+1]
set y, [i+2]
set a, [i]
hwi [z]
;IF B == 1: RETURN
ife b, 1
set pc, .ret
;Fail current
set a, 0 ;POLL
hwi [z]
set [i], c
bor [i], 0x10
set a, [i+3]
jsr pm_unblock
;IF queue empty: RETURN
set i, [i+4]
ifn i, 0
set pc, .mainloop
:.ret
set [z+1], i
ife i, 0
set [z+2], 0
set i, pop
set z, pop
set y, pop
set x, pop
set c, pop
set pc, pop


;A=operation type
;B=sector to work on
;C=memory to work on
;X=drive to work on
;RETURN: A=success or errorcode
:dm_add
iaq 1 ;Turn on interrupt queuing while adding entry so the handler doesn't mess up if an interrupt comes in in the middle.
shl x, 2
add x, [dm_drive_data]
set push, 0 ;next operation
set push, [pm_current_process]
set push, c
set push, b
set push, a
ife [x+1], 0 ;queue is empty
set pc, .emptyqueue
;queue is not empty
set a, [x+2]
set [a+4], sp
set [x+2], sp
set pc, .wait
:.emptyqueue
set [x+1], sp
set [x+2], sp
set b, x
jsr dm_handler
:.wait
iaq 0
:.loop_a
ifn a, 2
ifn a, 3
set pc, .finish
jsr pm_block_me
set pc, .loop_a
:.finish
set a, pop
set b, pop
set c, pop
add sp, 2 ;2 more pops
set pc, pop

:dm_drive_num .dat 0x0000
:dm_drive_data .dat 0x0000

;DRIVE ENTRY:
;0x0 hardware address
;0x1 current operation
;0x2 last operation
;0x3 reserved

;OPERATION ENTRY:
;0x0 0=success/2=read/3=write/0x10&ERROR=failure/0x20=global failure
;0x1 sector to work on (X)
;0x2 memory to work on (Y)
;0x3 thread to unblock when done
;0x4 next operation