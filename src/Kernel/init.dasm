;INITIATE KERNEL by Lucus

;This initiator is the first process

;For the memory manager, section info:
.dat init_stack - 2, 0 ;last section

:init
set sp, init_stack_end

:fd_init
set [fd_current_drive], [0xffff]

:im_init
hwn a
shl a, 1
jsr mm_request
ife a, -1
jsr fatal_error ;Does not return
set [im_table_address], a
ias im_interrupt_handler

:io_init
hwn z
set a, z
jsr mm_request
ife a, 0xffff
jsr fatal_error
set [.varpointer], a
set i, a
set j, 0x0

:.drive_loop0
hwq j
ife a, 0x24c5  
        ife b, 0x4fd5
                jsr .add_drive
ife j, z
        set pc, .exit0
ife [io_drive_count], 0xf	;exit if the number of drives found is 16
        set pc, .exit0
add j, 1
set pc, .drive_loop0

:.add_drive
set [i], j
add i, 1
add [io_drive_count], 1
set pc, pop

:.exit0
set a, [io_drive_count]
set j, [.varpointer]
set i, 0x0
set x, a
mul a, 0x9	;9 = Length of a drive data table entry + Job request for each drive
jsr mm_request
ife a, 0xffff
jsr fatal_error
set y, a
set [io_drive_data], a
set z, x
mul z, 5
add z, a
:.loop1
ifg i, x
        set pc, .exitloop1
set [y], j	;Hardware address
set [y+1], 0x0	;Slightly redundant.  
set [y+2], z
hwi [y]
ife c 0xffff
        set pc, .broken
set a, io_operator
set b, [y]
bor b, [im_hardware_flag]
jsr im_request
set pc, [b+.ref]
:.ref
.dat .nomedia
.dat .ready
.dat .wp
.dat .busy
:.nomedia
and [y+1], 0xfffd
set pc, .refend
:.ready
bor [y+1], 0x7
set pc, .refend
:.busy
set pc, .loop1
:.broken
and [y+1], 0xfffe
set pc, .refend
:.wp
bor [y+1], 0x3
and [y+1], 0xfffb
:.refend
add y, 5	;go to the next entry location.
add z, 5	;move z to the next job request array location.
sti pc, .loop1

:exitloop1
set a, .varpointer
jsr mm_free
ife a, 0xffff
jsr fatal_error

:pm_init
;nothing to do here

:api_init
set a, api_table_length
set i, api_table
set j, 0
jsr ut_copy_mem

:cd_init			;initiate the clock, clock interrupts start after this
hwn i
sub i, 1
:.loop_a
ife i, -1
set pc, .no_clock
hwq i
ife a, 0xb402
ife b, 0x12d0
set pc, .found_clock
std pc, .loop_a
:.no_clock
set [cd_clock_id], -1
jsr fatal_error
:.found_clock
set [cd_clock_id], i
set a, i
set b, cd_interrupt_handler
jsr im_request
set b, i
add b, im_hardware_flag
set a, 2
hwi i
set a, 0
set b, 1
hwi i

set x, 7
jsr pm_add ;Load dummy.bin, located in sector 7.
set [pm_semaphore], 0 ;Let the scheduling begin
jsr pm_kill_me

sub pc, 1

:fatal_error
set a, 0xffff
set b, a
set c, b
set x, c
set y, x
set z, y
set i, 0
set j, 0
add j, 1
add i, ex
sub pc, 3

;DATA
:api_table
.include "api.dasm"

:init_end

;For the memory manager, section info:
.dat 0xffff, -init_stack_end ;last section

:init_stack

.reserve 64

:init_stack_end

