;INITIATE KERNEL by Lucus

;This initiator is the first process

;For the memory manager, section info:
.dat init_stack - 2, 0 ;last section

:init
set sp, init_stack_end

:fd_init
set [fd_current_drive], [0xffff]

:im_init
hwn a
shl a, 1
jsr mm_request
ife a, -1
jsr fatal_error ;Does not return
set [im_table_address], a
ias im_request
ife a, err_already_in_use
set pc, fatal_error

:io_init
hwn z
set j, 0x0
set a, z
jsr mm_request
ife a, 0xffff
jsr fatal_error
set [.varpointer], a
set i, a
 
:.drive_loop0
hwq j
ife a, 0x24c5  
        ife b, 0x4fd5
                jsr .add_drive
ife j, z
        set pc, .exit0
ife [io_drive_count], 0xf ; exit if the number of drives found is 16
        set pc, .exit0
add j, 1
set pc, .drive_loop0

:.add_drive
set [i], j
add i, 1
add [io_drive_count], 1
set pc, pop
 
:.exit0
set a, [io_drive_count]
set j, [.varpointer]
set i, 0x0
set b, a
set x, a
mul a, 0x7 ; length of a drive data Entry 
mul b, 0x50 ; job list length for each drive
add a, b
jsr mm_request
ife a, 0xffff
jsr fatal_error
set y, a
set [io_drive_data], y
add b, a
set z, b
:.loop1
ifg i, x
        set pc, .exitloop1
set [y], j; hardware address
add j, 1
add i, 1
set [y+1], z; job list location
set [y+3], z; current entry pointer
set [y+6], io_fake_entry;used to handle any errors the IO will give on the first operation. 
add z, 0x50
add y, 7
set pc, .loop1
 
:.exitloop1
set i, io_drive_count
set z, 0x0
:.loop2
ifg z, i
         set pc, .exitloop2
set a, 0
set [y+2], 0x0 ;used to make sure that we have a blank slate when doing bors
hwi [y]
ife b, 0xffff
        set pc, fatal_error
:.ref
set pc, [b+.ref]
.dat .nomedia
.dat .ready
.dat .wp
.dat .halt
 
:.nomedia
and [y+2], 0xfffd
set pc, .refend
:.ready
bor [y+2], 0x2
set pc, .refend
:.halt
set pc, fatal_error
:.wp
bor [y+2], 0x4

:.refend
add y, 7; go to the next entry location
add z, 1
set pc, .loop2
 
:.exitloop2
set i, .varpointer
sub i, 0x1
set x, i
add x, io_drive_count
set c, 0xffff
:.loop3
;i is the location of the HWI numbers
add c, 1
add i, 1
set a, io_operator
set b, [i]
add b, im_hardware_flag
jsr im_request
set a, 1
hwi [i]
ife x, i
	set pc, exitloop3
set pc, .loop3

:.varpointer
.dat 0x0

:exitloop3
sub i, io_drive_count
set a, i
jsr mm_free
ife a, 0xffff
jsr fatal_error


:pm_init
;nothing to do here

:api_init
set a, api_table_length
set i, api_table
set j, 0
jsr ut_copy_mem

:cd_init			;initiate the clock, clock interrupts start after this
hwn i
sub i, 1
:.loop_a
ife i, -1
set pc, .no_clock
hwq i
ife a, 0xb402
ife b, 0x12d0
set pc, .found_clock
std pc, .loop_a
:.no_clock
set [cd_clock_id], -1
jsr fatal_error
:.found_clock
set [cd_clock_id], i
set a, i
set b, cd_interrupt_handler
jsr im_request
set b, i
add b, im_hardware_flag
set a, 2
hwi i
set a, 0
set b, 1
hwi i

set x, 7
jsr pm_add ;Load dummy.bin, located in sector 7.
set [pm_semaphore], 0 ;Let the scheduling begin
jsr pm_kill_me

sub pc, 1

:fatal_error
set a, 0xffff
set b, a
set c, b
set x, c
set y, x
set z, y
set i, 0
set j, 0
add j, 1
add i, ex
sub pc, 3

;DATA
:api_table
.include "api.dasm"

:init_end

;For the memory manager, section info:
.dat 0xffff, -init_stack_end ;last section

:init_stack

.reserve 64

:init_stack_end

