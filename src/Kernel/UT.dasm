;UTILITIES by Lucus

:ut_pushr
set ex, pop
set push, a
set push, b
set push, c
set push, i
set push, j
set push, x
set push, y
set push, z
set pc, ex

:ut_popr
set ex, pop
set z, pop
set y, pop
set x, pop
set j, pop
set i, pop
set c, pop
set b, pop
set a, pop
set pc, ex

:ut_pushx
xor ex, peek	;swap ex, peek
xor peek, ex	;
xor ex, peek	;
set push, a
set push, b
set push, c
set push, i
set push, j
set push, x
set push, y
set push, z
set pc, ex

:ut_popx
set ex, pop
set z, pop
set y, pop
set x, pop
set j, pop
set i, pop
set c, pop
set b, pop
set a, pop
xor ex, peek	;swap ex, peek
xor peek, ex	;
xor ex, peek	;
set pc, pop

;Copy A words of memory from I to J
:ut_copy_mem
set push, a
add a, i
mul peek, -1
and peek, 15
add pc, pop
:.loop_a
sti [j], [i]
sti [j], [i]
sti [j], [i]
sti [j], [i]
sti [j], [i] ;
sti [j], [i] ;
sti [j], [i] ;
sti [j], [i] ;
sti [j], [i]
sti [j], [i]
sti [j], [i]
sti [j], [i]
sti [j], [i] ;
sti [j], [i] ;
sti [j], [i] ;
sti [j], [i] ;
ifl i, a
sub pc, 18
set pc, pop

;Fill A words of memory starting at I with B
:ut_fill_mem
set push, a
add a, i
mul peek, -1
and peek, 15
add pc, pop
:.loop_a
sti [i], b
sti [i], b
sti [i], b
sti [i], b
sti [i], b ;
sti [i], b ;
sti [i], b ;
sti [i], b ;
sti [i], b
sti [i], b
sti [i], b
sti [i], b
sti [i], b ;
sti [i], b ;
sti [i], b ;
sti [i], b ;
ifl i, a
sub pc, 18
set pc, pop

;Compare A words of memory starting at I and J
;Returns A is 0 if [I] through [I + A - 1] equals [J] through [J + A - 1]
;Returns A is 1 if the memory at I is bigger than the memory at J as a Big Endian BigInt
;Returns A is -1 if the memory at J is bigger than the memory at I as a Big Endian BigInt
:ut_compare_mem_be
add a, i
:.loop_a
ife [i], [j]
ifl i, a
sti pc, .loop_a
set a, 0
ifg [i], [j]
set a, 1
ifg [j], [i]
set a, -1
set pc, pop

;Compare A words of memory starting at I and J
;Returns A is 0 if [I] through [I + A - 1] equals [J] through [J + A - 1]
;Returns A is 1 if the memory at I is bigger than the memory at J as a Little Endian BigInt
;Returns A is -1 if the memory at J is bigger than the memory at I as a Little Endian BigInt
:ut_compare_mem_le
set push, i
add i, a
add j, a
set a, pop
:.loop_a
ife [i], [j]
ifg i, a
std pc, .loop_a
set a, 0
ifg [i], [j]
set a, 1
ifg [j], [i]
set a, -1
set pc, pop

