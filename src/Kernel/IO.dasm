;I/O SCHEDULER by LukeW4lker
;NOTES:
;j is used to work  data array 
;i is used to work with the queue
;Queue references still need to be changed to "job list" or just "list"
;DATA

:io_drive_data
.dat 0x0
:io_drive_count
.dat 0x0

:io_operator
set push, i
set push, j
set push, z
set push, y
set push, x
set push, c
set push, a
set j, b
mul j, 0x5 ; length of drive data entry
add j, [io_drive_data]
set y, j
;j is the current drive data entry
set a, 0
set b, 0
hwi [j]
ife c, 0xffff
	set pc, .drivedead
set pc, [c + .cref]
:.cref
.dat .chkb	;no error, mark previous job as good. 
.dat .busy	;return quickly 
.dat .no_media	;return fail for all
.dat .wp	;return fail for all 
.dat .ejectd	;return fail for all
.dat .bad_sector;  return failure for current item

:.drivedead
and [j+1], 0xfffe
set pc, .exitjob

:.busy
bor [j+1], 0x0100
set pc, .exitjob

:.wp
bor [j+1], 0x0300
set pc, .exitjob

:.ejectd
bor [j+1], 0x0400
set pc, .exitjob

:.no_media
and [j+1], 0xfffd
set pc, .exitjob

:.bad_sector
bor [i+1], 0x0500 
set pc, .exitjob

:.chkb
ifn b, 0x0 
	set pc, .bref0
and [j+1], 0xfffd
bor [j+1], 0x0400
set pc, .exitjob
:.bref0
and [j+1], 0xff	;Mark the drive as not having a previous error
ife b, 0x3	;Drive is busy
set pc, .return
set i, [j+2]
ife [i+1], 0	;check if done.
set pc, .exitjob
and i, 1
ife i, 1
set pc, .write
set pc, .read
:.perform_job
add [i+2], 0x200;Incriment memory pointer
sub [i+1], 1
set y, [i+2]	;Memory to use
set i, [i]
add i, 1
set x, [i+2]	;Sector
hwi [j]		;Obvious Hardware interrupt number
:.return
set  c, pop
set  x, pop
set  y, pop
set  z, pop
set  i, pop
set  j, pop
set pc, pop
:.write
add b, 1
:.read
add b, 1
set pc, .perform_job
:.exitjob
set a, [j+4]
jsr pm_unblock 
set pc, .return

:io_get_drive_entry
;input x drive number
;output is c as the location of the entry
;c is 0xffff if out of bounds
ifg x, [io_drive_count]
set pc, .err0
set c, x
mul c, 4;  length of drive data entry
add c, io_drive_data
set pc, pop
:.err0
set c, 0xffff
set pop

:io_aquire
;Used to aquire control of the IO so the calling thread can use the drive.
;c is the drive data entry
;sets ex to 0x1 if the drive is already held or 0x2 if the drive is out of bounds.
;if ex is 0, the current process has control of the IO.
;destroys b
set b, [c+2]
IAQ 1
and b, 0xB
ifn b, 0x3; check if drive is held, alive and has a disk.
set pc, .err1
bor [c+2], 0x8 ;acquire ownership
set [c+4], [current_process]
IAQ 0
set ex, 0x0
set pc, pop
:.err0
set ex, 0x1
set pc, pop
:.err1
set ex, 0x2
set pc, pop

:io_work
;a is a pointer to the task list
;b is the memory to use(MUST BE CONTIGUOUS, I do not check if you have enough room, that is your job). 
;c is the drive data entry pointer
;y is the flag
;NOTES:Will operate based on how the y flag is set.
;Y will be 0xfffe if writing is permitted and 0xffff if ther is a drive error, check the drive data entry for more info.
set i, [c+1]
and i, 4
set j, y
and j, 1
ife i, 0	;Check if write operation is permitted if it's requested. 
ifn j, 0
set pc, .err0	;Write operation isn't permitted.
set j, [c+2] 
set [j], y
set [j+1], [a]	;set the number of sectors left to go
set [j+2], b	;sets the memory location  
int [c]		;mimic drive changing state.
set j, y
and j, 2
:.loop0
jsr pm_hurry
set i, [c+1]
shr i, 0x8
ifg i, 0x0
set pc, .errchck0
set pc, .loop0
:.errchck0
ife i, 0xff
set pc, .exiterr
ife j, 2
ife i, 0x3
set pc, .continue
ife i, 0x5
set pc, .done
set pc, .exiterr
:.continue
int [c]
set pc, .loop0
:.exiterr
set y, 0xffff
set pc, pop
:.err0
set y, 0xfffe
set pc, pop
