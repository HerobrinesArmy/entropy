; --------------------------------------------
; Title:   multitasker
; Author:  Alex
; Date:    10/15/2012
; Version: 
; --------------------------------------------

;@name multitasker_addProg
;adds a program to the program tables
;@params A the PC of the program's start
;@returns A the program ID (needed to kill it), -1 if there wasn't room
;@see thePalindrome	
:multitasker_addProg ; TODO, load the program into memory
    SET PUSH, B
	SET PUSH, C
	SET C, 0
	SET B, multitasker_Progs_0
	SUB B, 0xB
	
	ADD C, 1
	ADD B, 0xB
	IFN [B], 0
	    IFL 0xF, C
	        SUB PC, 5 ; B now points to an empty program slot
	
    IFL 0xF, C
		ADD PC, 4
	SET A, -1
	SET C, POP
	SET B, POP
	SET PC, POP
	
	
	SET [B], A
	
	SET A, B
	SET C, POP
	SET B, POP
	SET PC, POP
	
;@name multitasker_killProg
;removes a program from the program list
;@params A the program ID
;@see thePalindrome
:multitasker_killProg ; TODO add special case if trying to kill current program
    MUL A, 0xB
    ADD A, multitasker_Progs_0
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	ADD A, 1
	SET [A], 0
	SET PC, POP
	
;@name multitasker_Interrupt
;handles the main interrupt NOTE: From top, stack is: PC (stay), PC (stay), A (replace), PC (replace)
;@see thePalindrome
:multitasker_Interrupt
    SET PUSH, A
	SET A, multitasker_Progs_0
	SET PUSH, B
	SET B, [multitasker_curProg]
	MUL B, 0xB
	ADD A, B
	SET B, POP ;at this point, A points to multitasker_Progs_(number of cur prog)
	ADD A, 1
	SUB [A], 1
	IFN [A], 0
	    SET PC, multitasker_Interrupt_End
		
	ADD A, 1
	SET [A], POP
	ADD A, 1
	SET [A], B
	ADD A, 1
	SET [A], C
	ADD A, 1
	SET [A], I
	ADD A, 1
	SET [A], X
	ADD A, 1
	SET [A], Y
	ADD A, 1
	SET [A], Z
	ADD A, 1
	SET [A], J
	
	SET B, SP
	ADD B, 3 ;B now points to the location in the Stack where the old program was running
	ADD A, 1
	SET [A], [B]
	
	SUB B, 3
	SET [A], B ; SP has been saved for the new program
	SUB A, 10
	
	ADD [multitasker_curProg], 1
	ADD A, 0xB
	IFL multitasker_Progs_end, A
	    SET A, multitasker_Progs_0
	IFE [A], 0 ;If there's no program loaded (+1 code of hangs-if-no-programs-available)
	    SUB PC, 7
		
	ADD A, 10 ; THIS IS THE PART WHERE WE LOAD A NEW PROGRAM
	SET SP, [A] ;The stack will now return to the new program
	SUB A, 9
	SET [A], 14 ; each program gets 14 ticks
	ADD A, 8 ; A now points to the J register of the new program
	SET J, [A]
	SUB A, 1
	SET Z, [A]
	SUB A, 1
	SET Y, [A]
	SUB A, 1
	SET X, [A]
	SUB A, 1
	SET I, [A]
	SUB A, 1
	SET C, [A]
	SUB A, 1
	SET B, [A]
	SUB A, 1
	SET A, [A]
	SET [current_process], [multitasker_curProg]
		
	:multitasker_Interrupt_End
    SET PC, POP
	
:multitasker_curProg dat 0

;Definition of datastructure
;Current PC
;How many ticks are left
;Registers (ABCIXYZJ)
;Where the stack is hiding
:multitasker_Progs_0 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_1 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_2 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_3 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_4 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_5 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_6 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_7 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_8 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_9 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_10 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_11 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_12 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_13 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_14 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_15 dat 0,0,0,0,0,0,0,0,0,0,0
:multitasker_Progs_end