; --------------------------------------------
; Title:   IEEE float lib
; Author:  Canino
; Date:    6/15/2012
; Version: 0.1
; --------------------------------------------

;All normal float operations are IEEE "half precision" which is 16 bits, or normal precision here
;All double floats are going to be IEEE "single precision" which is 32 bits
;Should handle inf values (numbers outside of range) implicitly
;And the great upside vs the other lib is a float is 1 word long, and should be less operations
;There are some limitations on representing some ints, but nothing to worry about if we are using it for percents.

;@see http://en.wikipedia.org/wiki/Half-precision_floating-point_format

#define FS_ZERO      0x0000
#define FS_NEGZERO   0x8000
#define FS_INF       0x7C00
#define FS_NINF      0xFC00
#define FS_NaN       0x7C01


;@name fadd
;Adds the floats stored at A and B (no pointers as these are single precision)
;Doesn't accept negatives at the moment. Old proof of concept code.
;@params A,B
;@destroys X,Y
;@returns A
;@see ColErr
:fadd
	SHL A, 6
	SET X, EX
	AND X, 0x1F
	SUB X, 15
	
	SHL B, 6
	SET Y, EX
	AND Y, 0x1F
	SUB Y, 15
	;X and Y now equal the exponent
	SHR A, 1
	BOR A, 0x8000
	SHR B, 1
	BOR B, 0x8000
	;A and B are now the significand with the extra digit
	IFG X, Y
		SET PC, .xgy 
	IFE X, Y
		SET PC, .cont
	SUB Y, X
	ADD X, Y
	SHR A, Y
	SET PC, .cont
	:.xgy
	SUB X, Y
	ADD Y, X
	SHR B, X
	SET X, Y
	SET PC, .cont
	
	;A and B are aligned, and X is the exponent
	:.cont
	ADD A, B
	IFE EX, 0
		SHL A, 1
	SHR A, 6
	ADD X, 15
	SHL X, 10
	BOR A, X
	
	SET PC, POP